<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>IO | 即使宇宙也不认识</title><meta name="keywords" content="apue"><meta name="author" content="soredake"><meta name="copyright" content="soredake"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="linux 文件种类  普通文件 - 目录文件 d 管道文件 p：一种用于进程间通信的特殊文件，也称为命名管道FIFO。 套接字文件s：一种用于网络间通信的特殊文件。 链接文件l：用于间接访问另外一个目标文件，相当于Windows快捷方式。 字符设备文件c：字符设备在应用层的访问接口。触摸屏 、液晶屏、键盘、鼠标 块设备文件b：块设备在应用层的访问接口。硬盘、U盘 、光盘   ls -l 第一列的">
<meta property="og:type" content="article">
<meta property="og:title" content="IO">
<meta property="og:url" content="https://mhyccc.github.io/2024/03/02/C%E8%AF%AD%E8%A8%80/IO/index.html">
<meta property="og:site_name" content="即使宇宙也不认识">
<meta property="og:description" content="linux 文件种类  普通文件 - 目录文件 d 管道文件 p：一种用于进程间通信的特殊文件，也称为命名管道FIFO。 套接字文件s：一种用于网络间通信的特殊文件。 链接文件l：用于间接访问另外一个目标文件，相当于Windows快捷方式。 字符设备文件c：字符设备在应用层的访问接口。触摸屏 、液晶屏、键盘、鼠标 块设备文件b：块设备在应用层的访问接口。硬盘、U盘 、光盘   ls -l 第一列的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://shaohua-1313651385.cos.ap-guangzhou.myqcloud.com/img/99549238_p0.png">
<meta property="article:published_time" content="2024-03-02T13:22:31.000Z">
<meta property="article:author" content="soredake">
<meta property="article:tag" content="apue">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://shaohua-1313651385.cos.ap-guangzhou.myqcloud.com/img/99549238_p0.png"><link rel="shortcut icon" href="https://raw.githubusercontent.com/foreverForth/source/main/img/109258181_p0.png"><link rel="canonical" href="https://mhyccc.github.io/2024/03/02/C%E8%AF%AD%E8%A8%80/IO/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: soredake","link":"链接: ","source":"来源: 即使宇宙也不认识","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'IO',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-03 14:14:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://shaohua-1313651385.cos.ap-guangzhou.myqcloud.com/img/113227262_p0.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章存档</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">即使宇宙也不认识</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章存档</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">IO</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-03-02T13:22:31.000Z" title="发表于 2024-03-02 21:22:31">2024-03-02</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>19分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="IO"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="linux-文件种类">linux 文件种类</h2>
<ol>
<li>普通文件 -</li>
<li>目录文件 d</li>
<li>管道文件 p：一种用于进程间通信的特殊文件，也称为命名管道FIFO。</li>
<li>套接字文件s：一种用于网络间通信的特殊文件。</li>
<li>链接文件l：用于间接访问另外一个目标文件，相当于Windows快捷方式。</li>
<li>字符设备文件c：字符设备在应用层的访问接口。触摸屏 、液晶屏、键盘、鼠标</li>
<li>块设备文件b：块设备在应用层的访问接口。硬盘、U盘 、光盘</li>
</ol>
<blockquote>
<p>ls -l 第一列的第一个字符 就代表文件种类</p>
</blockquote>
<h2 id="IO简介">IO简介</h2>
<p>I/O是在内存和外部设备（磁盘驱动器、网络、终端）之间复制数据的过程。输入是从外部 设备复制到内存，输出是从内存复制到外部设备。</p>
<p>在Linux系统中所有的I/O设备都被映射称为文件，所有的输入输出都被当做相应文件的读和写来执行， 所以内核提供了系统级的I/O函数接口，使得所有输入输出都以统一且一致的方式来执行。</p>
<p>文件读写的过程</p>
<ol>
<li>打开文件，返回一个非负整数，叫做描述符</li>
<li><strong>每个进程都默认打开三个描述符</strong>
<ol>
<li>标准输入 STDIN_FILENO（描述符0）</li>
<li>标准输出  STDOUT_FILENO（描述符1）</li>
<li>标准出错 STDERR_FILENO（描述符2）</li>
</ol>
</li>
<li>读写文件，读就是从文件复制n个字节到内存，写就是从内存复制n个字节到文件。</li>
<li><strong>文件偏移：默认打开文件是从文件开头起始的字节偏移量，可以使用seek来操作。</strong></li>
<li><strong>关闭文件。</strong></li>
</ol>
<p><strong>文件描述符fd 是什么？</strong></p>
<p>打开或新建文件后，Linux会返回一个非负整数，就是文件描述符，从0开始分配，012是预先分配好的，分别是stdin，stdout，stderr，fd相当于标准IO中的文件指针fp。</p>
<p><strong>另外文件描述符实际上也标记了打开的文件，之后 read, write, lseek函数的第一个参数都是这个文件描述符</strong></p>
<p>在 Linux 系统中，不能无限制打开很多的文件</p>
<p>查看最大限制命令  <code>ulimit -n</code></p>
<p><strong>被占用的012定义在哪里?</strong></p>
<p><code>在程序执行的时候，就会默认打开3个文件</code>，分别是&quot;标准输入&quot;、“标准输出”、“标准出错”，他们其实是一个宏定义来 的，是被定义在一个头文件中，头文件路径：/usr/include/unistd.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STDIN_FILENO    0       <span class="comment">/* Standard input.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STDOUT_FILENO   1       <span class="comment">/* Standard output.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STDERR_FILENO   2       <span class="comment">/* Standard error output.  */</span></span></span><br></pre></td></tr></table></figure>
<h2 id="文件IO">文件IO</h2>
<h3 id="文件IO-标准IO">文件IO/标准IO</h3>
<img src="https://shaohua-1313651385.cos.ap-guangzhou.myqcloud.com/img/image-20240522093609761.png" alt="image-20240522093609761" style="zoom: 67%;" />
<p>⭐<strong>标准IO是应用程序和库函数之间的接口，由C库提供，与操作系统无关，代码迁移简单</strong></p>
<p>⭐文件IO、又叫系统IO、系统调用，<strong>是库函数与操作系统之间的接口</strong>，接近底层，不同的OS的实现也不同，比如ubuntu这里是open，可能在其他操作系统里函数名不同且实现也不同。</p>
<p>⭐系统IO没有缓冲机制，标准IO有缓冲机制。</p>
<img src="https://shaohua-1313651385.cos.ap-guangzhou.myqcloud.com/img/image-20240522093706298.png" alt="image-20240522093706298" style="zoom:67%;" />
<p><strong>系统调用是什么？</strong></p>
<p>用户不能直接操作内核，所以在内核提供了接口供用户调用，这个就是系统调用。</p>
<p>文件IO就是系统调用。标准IO是再向上一层的封装，它在用户空间添加了缓冲区，就是在内存申请一块空间用来存放读写的数据，这也是为什么它有缓冲机制，而文件IO没有。</p>
<p><strong>为什么要搞两套？直接用系统IO不行吗？</strong></p>
<p>因为系统不同 linux，mac，windows，如果直接系统调用，移植代码就很麻烦。所以主流操作系统都实现了c库，而我们只需要调用c库就行，而不需要改很多代码。</p>
<h3 id="第一个读写程序">第一个读写程序</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> fd1, fd2;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	fd1 = open(<span class="string">&quot;data.txt&quot;</span>, O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span> (fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;open data.txt&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fd2 = open(<span class="string">&quot;file.txt&quot;</span>, O_WRONLY | O_CREAT, <span class="number">0644</span>);</span><br><span class="line">	<span class="keyword">if</span> (fd2 == <span class="number">-1</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;open file.txt&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = read(fd1, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(buf);</span><br><span class="line"></span><br><span class="line">	ret = write(fd2, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	close(fd1);</span><br><span class="line">	close(fd2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="man手册">man手册</h3>
<ul>
<li>man 1 ls 1表示Linux命令</li>
<li>man 2 open 2表示系统调用</li>
<li>man 3 printf 3 表示C库函数</li>
</ul>
<h3 id="系统IO-API">系统IO API</h3>
<h4 id="open">open</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>
<p>成功返回值是一个非负整数，也就是文件描述符，打开失败返回-1</p>
<p>pathname 指定要打开的文件</p>
<p>flags 指定要用什么模式去打开</p>
<blockquote>
<p>man手册原文</p>
<p>The  argument  flags must include one of the following  access  modes:  <strong>O_RDONLY,  O_WRONLY,   or O_RDWR</strong>.   These  request  opening  the file read-only, write-only, or read/write, respectively.</p>
</blockquote>
<p>可选参数</p>
<ol>
<li>O_TRUNC：如果文件存在并且是一个普通文件，而且打开方式是O_WRONLY/O_RDWR，那么这个文件就会被清空。</li>
<li>O_APPEND ：追加的方式打开，The  file is opened in append mode.</li>
<li>O_CREAT ：如果文件不存在则创建，If the file does not exist it will be created.</li>
<li>O_EXCL ：和O_CREAT一块使用，如果文件存在则报错</li>
<li>O_NONBLOCK ：非阻塞的方式打开文件</li>
</ol>
<p>这些参数一起使用时 用 位运算符<code>|</code>连接</p>
<p><strong>mode 指定文件权限，只有在需要创建文件时，也就是 flags指定了 O_CREAT 才有效</strong></p>
<p>换句话说，如果flags没有指定 O_CREAT，mode参数是无效的。</p>
<blockquote>
<p>The open() system call opens the file specified  by  pathname. If  the  specified file does not exist, it may optionally (if O_CREAT is specified in flags) be created  by open().</p>
</blockquote>
<p>四个八进制位指定，以0766为例</p>
<ul>
<li>0： 没有特殊权限</li>
<li>7： 文件所属用户 有 rwx权限  r：4 w：2 x：1</li>
<li>6： 同组用户 有 rw权限</li>
<li>6： 其他用户有 rw权限</li>
</ul>
<p>除了这种写法，还可以通过系统定义好的宏指定</p>
<ol>
<li><code>S_IRWXU  </code>00700 user (file owner) has read, write, and execute permission</li>
<li><code>S_IRUSR</code>00400 user has read permission</li>
<li><code>S_IWUSR  </code>00200 user has write permission</li>
<li><code>S_IXUSR  </code>00100 user has execute permission</li>
<li><code>S_IRWXG  </code>00070 group has read, write,  and execute permission</li>
<li><code>S_IRGRP  </code>00040 group has read permission</li>
<li><code>S_IWGRP  </code>00020 group has write permission</li>
<li><code>S_IXGRP  </code>00010  group  has execute permission</li>
<li><code>S_IRWXO  </code>00007 others  have  read,  write, and execute permission</li>
<li><code>S_IROTH  </code>00004 others have read permission</li>
<li><code>S_IWOTH  </code>00002  others  have write permission</li>
</ol>
<p>第一个0指八进制位，第二位指特殊权限值，第三位文件所属用户，第四位同组用户，第五位其他用户</p>
<p>不过一般用四位即可，表示四种权限</p>
<h4 id="read">read</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>read()  attempts to read up to count bytes from file descriptor fd into the buffer starting at buf.</p>
</blockquote>
<ol>
<li>成功返回读到的字节数 可能小于 count，失败返回-1，并且设置错误码errno</li>
<li>fd 文件描述符</li>
<li>buf 文件内容读到哪个缓冲区地址</li>
<li>count 要读多少字节</li>
</ol>
<p>errno 是 &lt;errno.h&gt; 中定义的变量，出现错误会被设置成2 成功就是0</p>
<h4 id="write">write</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>write()  writes  up to count bytes from the buffer starting at buf to the file referred to by the file descriptor fd.</p>
</blockquote>
<ol>
<li>成功返回写入的字节数 可能小于 count，失败返回-1，并且设置错误码errno</li>
<li>fd 文件描述符</li>
<li>buf 哪个缓冲区的内容写到文件中</li>
<li>count 要读多少字节</li>
</ol>
<h4 id="lseek">lseek</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure>
<p>作用：移动文件指针</p>
<ol>
<li>成功返回当前位置，失败返回-1 并且设置错误码 errno</li>
<li>fd  文件描述符</li>
<li>whence 偏移参考点
<ol>
<li>SEEK_SET 文件起始位置</li>
<li>SEEK_CUR 当前位置</li>
<li>SEEK_END 文件末尾</li>
</ol>
</li>
<li>offset 相对于 whence的偏移量</li>
</ol>
<p>flags 为 O_APPEND时，因为是追加，文件指针直接从文件末尾开始</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> fd1;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	fd1 = open(<span class="string">&quot;./file.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">00644</span>);</span><br><span class="line">	<span class="keyword">if</span> (fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;open file.txt&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = write(fd1, <span class="string">&quot;hello world\n&quot;</span>, <span class="number">12</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;write file.txt&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lseek(fd1, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">	ret = read(fd1, buf, <span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	ret = write(fd1, <span class="string">&quot;123&quot;</span>, <span class="number">3</span>);</span><br><span class="line">	lseek(fd1, <span class="number">-2</span>, SEEK_END);</span><br><span class="line">	ret = write(fd1, <span class="string">&quot;45&quot;</span>, <span class="number">2</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">puts</span>(buf);</span><br><span class="line"></span><br><span class="line">	close(fd1);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>lseek函数不仅可以用来调整当前文件偏移量，而且还可以将文件位置偏移到文件之外，形成一个 空洞，这种特性其实是非常重要的，它提供了可以在不同地方同时写一个文件的可能，对于一个较大的 文件我们可以在文件中定位到一个指定的地方，让多个进程同时在不同的偏移量处写入文件数据。相当 于网络中的多点下载。</p>
</blockquote>
<h3 id="文件管理">文件管理</h3>
<p>文件储存在硬盘上，硬盘的最小存储单位叫做“扇区”（Sector），每个扇区储存512字节（相当于 0.5KB）， 操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多 个扇区，即一次 性读取一个“块”（block）。这种由多个扇区组成的“块”，是文件存取的最小单位。“块”的 大小，最常 见的是4KB，即连续八个sector组成一个block。</p>
<p>磁盘在进行分区、格式化的时候会将其分为两个区域，一个是数据区，用于存储文件中的数据； 另一个 是inode区，用于存放inode table（inode表）</p>
<p><strong>每一个文件都必须对应一个inode，inode实质上是 一个结构体，这个结构体是通过inode编码在inode表中找到的，这个结构体记录了文件了不同信息</strong>，譬如文件字节大小、文件所有者、文件对应的读/写/执行权限、文件时间戳（创建时间、更新时间等）、文件类型、文件数据 存储的block（块） 位置等等信息</p>
<p>Linux中可以通过 <code>ls -il</code> 和 <code>stat</code>命令查看 inode编号</p>
<p><strong>打开文件这个过程中做了什么？</strong></p>
<p>在Linux 系统中，内核会为每个进程设置一个专门的数据结构用于管理该进程，用来记录进程的状态信息、运行特征等，我们把这个称为进程控制块（Process control block，缩写 PCB）。</p>
<p>PCB 数据结构体中有一个指针指向了文件描述符表（File descriptors），文件描述符表中的每一个文件描述符fd索引到对应的文件表（File table），文件表也是一个数据结构体，其中记录了很多文件相关的信息，譬 如文 件状态标志、引用计数、当前文件的读写偏移量以及i-node指针（指向该文件对应的inode）</p>
<img src="https://shaohua-1313651385.cos.ap-guangzhou.myqcloud.com/img/image-20240523083213985.png" alt="image-20240523083213985" style="zoom: 50%;" />
<h2 id="标准IO">标准IO</h2>
<h3 id="标准IO介绍">标准IO介绍</h3>
<p>标准IO是文件IO的又一层封装。</p>
<p>文件IO是系统调用，不同操作系统实现不同，标准IO是标准C库实现，不同操作系统实现也是相同的，所以代码移植容易。</p>
<p>性能上，标准IO引入了缓冲机制，在用户空间中定义了stdio缓冲区，性能优于文件IO</p>
<h3 id="file指针">file指针</h3>
<p>相当于 文件IO中的文件描述符，实际上这两个也是可以互相转换的，由库函数实现</p>
<p><code>FILE *fp</code>中的FILE就是一个结构体。 FILE 是一个结构体数据类型，它包含了标准I/O库函数为管理文件所需要的所有信息，包括用于实 际 I/O 的文件描述符、指向文件缓冲区的指针、缓冲区的长度、当前缓冲区中的字节数以及出错标志等。FILE 数据结构定义在标准I/O库函数头文件stdio.h中。</p>
<h3 id="标准IO-API">标准IO API</h3>
<h4 id="fwrite-fread">fwrite / fread</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The  function  fread()  reads nmemb items of data, each size bytes long, from the stream pointed to by stream, storing them at the location given by ptr.</p>
<p>The  function fwrite() writes nmemb items of data, each size bytes long, to the stream pointed to by stream, obtaining  them  from  the  location given by ptr.</p>
<p>On  success,  fread()  and  fwrite()  return the number of items read or written.  This number equals the number of bytes transferred  only  when size  is  1.  If an error occurs, or the end of the file is reached, the return value is a short item count (or zero).</p>
<p>fread()  does not distinguish between end-of-file and error, and callers must use feof(3) and ferror(3) to determine which occurred.</p>
<p>后面有 feof和ferror 1</p>
</blockquote>
<ul>
<li>size参数表示 每块多少字节</li>
<li>nmemb 表示 这次读写 多少块</li>
</ul>
<h4 id="fopen">fopen</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来 将文件描述符转为FILE指针 就可以使用标准IO的方法</span></span><br><span class="line">FILE *<span class="title function_">fdopen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>fopen mode参数和 open mode参数 的对应关系</strong></p>
<img src="https://shaohua-1313651385.cos.ap-guangzhou.myqcloud.com/img/image-20240523145030310.png" alt="image-20240523145030310" style="zoom: 80%;" />
<h4 id="feof-ferror">feof / ferror</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clearerr</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ferror</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The function clearerr() clears the end-of-file and error indicators for the stream pointed to by stream.</p>
<p>The  function  feof()  tests  the  end-of-file indicator for the stream pointed to by stream, <strong>returning nonzero  if  it  is  set.</strong> The  end-of-file  indicator  can be cleared only by the function clearerr().</p>
<p>The function ferror() tests the error indicator for  the  stream  pointed to by stream, returning nonzero if it is set.  The error indicator can be reset only by the clearerr() function.</p>
</blockquote>
<p>读到文件结尾,<code>end-of-file</code>标识会被设置，这是一种错误情况。</p>
<p>当出现IO错误时（不是读到文件末尾，可能是各种错误），错误标识被设置，这是另一种错误情况。</p>
<p>想区分这两种情况，根据不同情况做出不同的处理，就要使用 feof和ferror</p>
<p>clearerr()作用是清空 <code>end-of-file</code>标识和 <code>error</code>标识 （就是error.h中定义的errno标识）</p>
<h4 id="文件指针定位">文件指针定位</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">ftell</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rewind</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>fseek 与系统调用 lseek 基本一样</li>
<li>ftell 返回当前文件指针位置</li>
<li>rewind 将文件指针移动到文件首部</li>
</ul>
<p><strong>代码案例</strong></p>
<ul>
<li>
<p>案例一（读写）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">	FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">1024</span>] = <span class="string">&quot;hello world nihao shijie`&quot;</span>;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	fp = fopen(<span class="string">&quot;file&quot;</span>, <span class="string">&quot;r+&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;fopen error&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = fwrite(buf, <span class="number">1</span>, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>, fp);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="built_in">strlen</span>(buf) + <span class="number">1</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// fseek(fp, 0, SEEK_SET);</span></span><br><span class="line">	rewind(fp);</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> buf1[<span class="number">1024</span>];</span><br><span class="line">	ret = fread(buf1, <span class="number">1</span>, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>, fp);</span><br><span class="line">	<span class="built_in">puts</span>(buf1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算文件大小</span></span><br><span class="line">	fseek(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;file size: %ld\n&quot;</span>, ftell(fp));</span><br><span class="line"></span><br><span class="line">	fclose(fp);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>案例二（错误处理）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">	FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fp = fopen(<span class="string">&quot;file&quot;</span>, <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	fseek(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">	<span class="keyword">if</span> ((ret = fread(buf, <span class="number">1</span>, <span class="number">12</span>, fp)) &lt; <span class="number">12</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (feof(fp)) &#123;</span><br><span class="line">			perror(<span class="string">&quot;到达末尾&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		clearerr(fp);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!feof(fp)) &#123;</span><br><span class="line">			perror(<span class="string">&quot;clearerror&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ferror(fp)) &#123;</span><br><span class="line">			perror(<span class="string">&quot;IO错误&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(buf);</span><br><span class="line">    </span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="格式化输出">格式化输出</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dprintf</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">snprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>函数说明</strong></p>
<blockquote>
<p>The functions in the printf() family produce output according to a  format  as  described  below.   The  functions  <strong>printf()  and write  output  to stdout, the standard output stream; fprintf() and write  output  to  the  given  output  stream; sprintf(), snprintf() write to the character string str.</strong></p>
<p>The function dprintf() is the same as fprintf() except  that  it outputs to <strong>a file descriptor, fd, instead of to a stdio stream.</strong></p>
<p>The  functions  snprintf()  write at most size bytes (including the terminating null byte (‘\0’)) to str.</p>
</blockquote>
<p>printf 相当于 stream == stdout 的fprintf</p>
<p><strong>案例：按格式打印当前时间</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">time_t</span> rawtime;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">timeinfo</span>;</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">24</span>]; <span class="comment">// 保证有足够的空间存放格式化后的时间字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前时间</span></span><br><span class="line">    time(&amp;rawtime);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将时间转换为本地时区的tm结构体</span></span><br><span class="line">    timeinfo = localtime(&amp;rawtime);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 snprintf进行时间格式化</span></span><br><span class="line">	<span class="built_in">snprintf</span>(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">&quot;%d-%d-%d %d:%d:%d&quot;</span>, timeinfo-&gt;tm_year + <span class="number">1900</span>, timeinfo-&gt;tm_mon + <span class="number">1</span>, timeinfo-&gt;tm_mday, timeinfo-&gt;tm_hour, timeinfo-&gt;tm_min, timeinfo-&gt;tm_sec);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    <span class="comment">// 使用strftime进行时间格式化</span></span><br><span class="line">    <span class="keyword">if</span> (strftime(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, timeinfo) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;时间格式化失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 输出格式化后的时间</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前时间是: %s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="IO缓冲">IO缓冲</h4>
<p>标准IO在用户空间引入缓冲区，又叫stdio缓冲区，文件IO没有，如下图</p>
<img src="C:\Users\13798\Downloads\嵌入式-第 2 页.drawio.png" alt="嵌入式-第 2 页.drawio" style="zoom: 67%;" />
<h5 id="内核缓冲区">内核缓冲区</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fsync</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fdatasync</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sync</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>fsync将参数fd所指的文件内容数据和元数据写入磁盘，对磁盘设备的写操作完成后，才会返回。调 用成功返回0，错误返回-1并设置errno指示错误原因。</li>
<li>fdatasync只是写入内容数据，不包括元数据（记录文件属性相关的数据信息）。</li>
<li>sync()会将所有文件I/O内核缓冲区中的文件内容数据和元数据全部更新到磁盘设备中，刷新所有文 件I/O内核缓冲区。</li>
</ul>
<p>除了手动调用函数刷新内核缓冲区，还可以在打开文件时，通过指定系统调用open方法中的flags参数实现每次读写操作后刷新内核缓冲区</p>
<ul>
<li>O_DSYNC  每个write调用后将数据同步，类似于fdatasync</li>
<li>O_SYNC 类似于 fsync</li>
</ul>
<h5 id="stdio缓冲区">stdio缓冲区</h5>
<p>标准I/O所维护的stdio缓冲是用户空间 的缓 冲区，当应用程序中通过标准I/O操作磁盘文件时，<strong>为了减少调用系统调用的次数</strong>，标准I/O函数会<strong>将用户写入或读取文件的数据缓存在stdio 缓冲区</strong>，然后再一次性将 stdio 缓冲区中缓存的数据<strong>通过调用系统调用I/O（文件I/O）写入到文件I/O内核缓冲区</strong>或者拷贝到应用程序的buf中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setvbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buf, <span class="type">int</span> mode, <span class="type">size_t</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setbuffer</span><span class="params">(FILE *stream, <span class="type">char</span> *buf, <span class="type">size_t</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setlinebuf</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>函数说明</strong></p>
<blockquote>
<p>The  setvbuf() function may be used on any open stream to change its buffer.  The mode argument must  be  one  of  the  following three macros:</p>
<p>_IONBF unbuffered 无缓冲</p>
<p>_IOLBF line buffered 行缓冲</p>
<p>_IOFBF fully buffered 全缓冲</p>
<p>Except  for unbuffered files, the buf argument should point to a buffer at least size bytes long; this buffer will  be  used  instead  of the current buffer.  If the argument buf is NULL, only the mode is affected; a new buffer will be allocated on the next read  or  write  operation.  就是说如果buf不是NULL，那么buf就是缓冲区，如果buf不是NULL，系统自动分配一块空间作为缓冲区</p>
<p>The  setbuffer()  function  is the same, except that the size of the buffer is up to the caller, rather than being determined  by  the default BUFSIZ.  The setlinebuf() function is exactly equivalent to the call:</p>
<p><code>setvbuf(stream, NULL, _IOLBF, 0);</code></p>
</blockquote>
<p><strong>案例：标准IO缓冲测试</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_FILE <span class="string">&quot;./file&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_FILE <span class="string">&quot;./wfile&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// setvbuf(stdout, NULL, _IONBF, 0);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="type">int</span> rfd, wfd;</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">	rfd = open(READ_FILE, O_RDONLY);</span><br><span class="line">	wfd = open(WRITE_FILE, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((size = read(rfd, buf, BUF_SIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">		write(wfd, buf, size);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(buf);</span><br><span class="line"></span><br><span class="line">	fsync(wfd);</span><br><span class="line"></span><br><span class="line">	close(rfd);</span><br><span class="line">	close(wfd);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结下刷新stdio缓冲区的方法</p>
<ul>
<li>换行符刷新缓冲区（行缓冲）</li>
<li>调用fflush()</li>
<li>调用fclose()关闭文件</li>
<li>程序退出时</li>
</ul>
<img src="C:\Users\13798\AppData\Roaming\Typora\typora-user-images\image-20240523182523202.png" alt="image-20240523182523202" style="zoom:67%;" />
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/apue/">apue</a></div><div class="post_share"><div class="social-share" data-image="https://shaohua-1313651385.cos.ap-guangzhou.myqcloud.com/img/99549238_p0.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/03/15/C%E8%AF%AD%E8%A8%80/%E9%AB%98%E7%BA%A7IO/"><img class="prev-cover" src="https://shaohua-1313651385.cos.ap-guangzhou.myqcloud.com/img/114061651_p0.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">高级IO</div></div></a></div><div class="next-post pull-right"><a href="/2024/02/15/C%E8%AF%AD%E8%A8%80/%E5%B9%B6%E5%8F%91/"><img class="next-cover" src="https://shaohua-1313651385.cos.ap-guangzhou.myqcloud.com/img/card_after_training.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">并发</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#linux-%E6%96%87%E4%BB%B6%E7%A7%8D%E7%B1%BB"><span class="toc-text">linux 文件种类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E7%AE%80%E4%BB%8B"><span class="toc-text">IO简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6IO"><span class="toc-text">文件IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6IO-%E6%A0%87%E5%87%86IO"><span class="toc-text">文件IO&#x2F;标准IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%AF%BB%E5%86%99%E7%A8%8B%E5%BA%8F"><span class="toc-text">第一个读写程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#man%E6%89%8B%E5%86%8C"><span class="toc-text">man手册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9FIO-API"><span class="toc-text">系统IO API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#open"><span class="toc-text">open</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#read"><span class="toc-text">read</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#write"><span class="toc-text">write</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lseek"><span class="toc-text">lseek</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-text">文件管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86IO"><span class="toc-text">标准IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86IO%E4%BB%8B%E7%BB%8D"><span class="toc-text">标准IO介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#file%E6%8C%87%E9%92%88"><span class="toc-text">file指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86IO-API"><span class="toc-text">标准IO API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fwrite-fread"><span class="toc-text">fwrite &#x2F; fread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fopen"><span class="toc-text">fopen</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#feof-ferror"><span class="toc-text">feof &#x2F; ferror</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%E5%AE%9A%E4%BD%8D"><span class="toc-text">文件指针定位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-text">格式化输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E7%BC%93%E5%86%B2"><span class="toc-text">IO缓冲</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-text">内核缓冲区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#stdio%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-text">stdio缓冲区</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By soredake</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">很高兴认识你</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://mhyccc.github.io/2024/03/02/C%E8%AF%AD%E8%A8%80/IO/'
    this.page.identifier = '/2024/03/02/C%E8%AF%AD%E8%A8%80/IO/'
    this.page.title = 'IO'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://mhy-1.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Disqus' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="你好,mhy" data-fontsize="15px" data-random="false" async="async"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>